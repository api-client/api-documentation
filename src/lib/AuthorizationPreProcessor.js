/* eslint-disable no-plusplus */
/* eslint-disable class-methods-use-this */
import { ArcHeaders } from '@advanced-rest-client/arc-headers';
import { UrlParser, Utils } from '@advanced-rest-client/arc-url';

/** @typedef {import('@advanced-rest-client/arc-types').ArcRequest.ArcBaseRequest} ArcBaseRequest */
/** @typedef {import('@advanced-rest-client/arc-types').Authorization.BasicAuthorization} BasicAuthorization */
/** @typedef {import('@advanced-rest-client/arc-types').Authorization.PassThroughAuthorization} PassThroughAuthorization */
/** @typedef {import('@advanced-rest-client/arc-types').Authorization.RamlCustomAuthorization} RamlCustomAuthorization */
/** @typedef {import('@advanced-rest-client/arc-types').Authorization.OAuth2Authorization} OAuth2Authorization */
/** @typedef {import('@advanced-rest-client/arc-types').Authorization.ApiKeyAuthorization} ApiKeyAuthorization */
/** @typedef {import('../types').AuthPreProcessorOptions} AuthPreProcessorOptions */

/**
 * @param {ArcHeaders} headers
 * @param {string} key
 * @param {any} value
 */
function applyHeader(headers, key, value='') {
  if (Array.isArray(value)) {
    value.forEach(v => applyHeader(headers, key, v));
  } else {
    headers.append(key, value);
  }
}

/**
 * @param {string[][]} params
 * @param {string} key
 * @param {any} value
 */
function applySearchParam(params, key, value='') {
  if (Array.isArray(value)) {
    value.forEach(v => applySearchParam(params, key, v));
  } else {
    params.push([Utils.encodeQueryString(key, true), Utils.encodeQueryString(String(value), true)]);
  }
}

/**
 * A class that applies authorization values generated by the HTTP editor, that can be 
 * applied before sending it to the HTTP factory.
 * 
 * These are the headers and query parameters defined by the security scheme.
 * 
 * Other methods like NTLM have to be processed by the HTTP factory when negotiating the connection.
 */
export class AuthorizationPreProcessor {
  /**
   * @param {ArcBaseRequest} request
   * @param {AuthPreProcessorOptions=} opts
   * @returns {ArcBaseRequest} A shallow copy of the request object.
   */
  apply(request, opts={}) {
    const copy = { ...request };
    const { authorization } = copy;
    if (!Array.isArray(authorization) || !authorization.length) {
      return copy;
    }
    const headers = new ArcHeaders(request.headers || '');
    const url = new UrlParser(request.url);
    
    const remove = [];
    let changed = false;
    authorization.forEach((method, index) => {
      const { config, enabled, valid, type } = method;
      if (enabled === false) {
        return;
      }
      if (valid === false && !opts.processInvalid) {
        return;
      }
      switch (type) {
        case 'basic': this.addBasic(headers, /** @type BasicAuthorization */ (config)); break;
        case 'pass through': this.addPassThrough(headers, url, /** @type PassThroughAuthorization */ (config)); break;
        case 'custom': this.addCustom(headers, url, /** @type RamlCustomAuthorization */ (config)); break;
        case 'oauth 2': this.addOAuth2(headers, url, /** @type OAuth2Authorization */ (config)); break;
        case 'api key': this.addApiKey(headers, url, /** @type ApiKeyAuthorization */ (config)); break;
        default: return;
      }
      changed = true;
      if (opts.removeProcessed) {
        remove.push(index);
      }
    });
    if (changed) {
      copy.headers = headers.toString();
      copy.url = url.toString();
    }

    if (remove.length) {
      const auth = [...authorization];
      copy.authorization = auth;
      for (let i = auth.length - 1; i >=0; i--) {
        if (remove.includes(i)) {
          auth.splice(i, 1);
        }
      }
    }
    return copy;
  }

  /**
   * Applies basic authorization scheme to the request.
   * It changes the request's headers.
   * 
   * @param {ArcHeaders} headers
   * @param {BasicAuthorization} config
   */
  addBasic(headers, config) {
    const { username='', password='' } = config;
    const hash = btoa(`${username}:${password}`);
    headers.append('Authorization', `Basic ${hash}`);
  }

  /**
   * Applies basic authorization scheme to the request.
   * It changes the request's headers and query parameters.
   * 
   * @param {ArcHeaders} headers
   * @param {UrlParser} parser
   * @param {PassThroughAuthorization} config
   */
  addPassThrough(headers, parser, config) {
    const { header, query } = config;
    if (header && typeof header === 'object') {
      Object.keys(header).forEach(key => applyHeader(headers, key, header[key]));
    }
    if (query && typeof query === 'object') {
      const params = parser.searchParams;
      Object.keys(query).forEach(key => applySearchParam(params, key, query[key]));
      // eslint-disable-next-line no-param-reassign
      parser.searchParams = params;
    }
  }

  /**
   * Applies RAML custom authorization scheme to the request.
   * It changes the request's headers and query parameters.
   * 
   * @param {ArcHeaders} headers
   * @param {UrlParser} parser
   * @param {RamlCustomAuthorization} config
   */
  addCustom(headers, parser, config) {
    const { header, query } = config;
    if (header && typeof header === 'object') {
      Object.keys(header).forEach(key => applyHeader(headers, key, header[key]));
    }
    if (query && typeof query === 'object') {
      const params = parser.searchParams;
      Object.keys(query).forEach(key => applySearchParam(params, key, query[key]));
      // eslint-disable-next-line no-param-reassign
      parser.searchParams = params;
    }
  }

  /**
   * Applies OAuth 2 authorization scheme to the request.
   * It changes the request's headers and query parameters.
   * 
   * @param {ArcHeaders} headers
   * @param {UrlParser} parser
   * @param {OAuth2Authorization} config
   */
  addOAuth2(headers, parser, config) {
    const { accessToken, deliveryMethod='header', deliveryName='Authorization', } = config;
    if (!accessToken) {
      return;
    }
    if (deliveryMethod === 'header') {
      applyHeader(headers, deliveryName, `Bearer ${accessToken}`);
    } else if (deliveryMethod === 'query') {
      const params = parser.searchParams;
      applySearchParam(params, deliveryName, accessToken);
      // eslint-disable-next-line no-param-reassign
      parser.searchParams = params;
    }
  }

  /**
   * Applies OAS' API key authorization scheme to the request.
   * It changes the request's headers and query parameters.
   * 
   * @param {ArcHeaders} headers
   * @param {UrlParser} parser
   * @param {ApiKeyAuthorization} config
   */
  addApiKey(headers, parser, config) {
    const { cookie, header, query } = config;
    if (header && typeof header === 'object') {
      Object.keys(header).forEach(key => applyHeader(headers, key, header[key]));
    }
    if (cookie && typeof cookie === 'object') {
      Object.keys(cookie).forEach(key => applyHeader(headers, 'cookie', `${key}=${cookie[key]}`));
    }
    if (query && typeof query === 'object') {
      const params = parser.searchParams;
      Object.keys(query).forEach(key => applySearchParam(params, key, query[key]));
      // eslint-disable-next-line no-param-reassign
      parser.searchParams = params;
    }
  }
}
